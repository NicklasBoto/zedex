-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Frontend.Zedex.Abs where

import Prelude (Char, Double, Int, Integer, String)
import qualified Prelude as C (Eq, Ord, Show, Read)
import qualified Data.String

newtype Id = Id ((Int, Int), String)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

newtype Scalar = Scalar String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

data Program = Progr [Toplevel]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Toplevel
    = ToplF Id [Id] Expr
    | ToplX Complex [Id] Expr
    | ToplZ Complex [Id] Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Expr
    = EVar Id
    | ETup Expr [Expr]
    | EUnit
    | EApp Expr Expr
    | EComp Expr Expr
    | EHad Expr
    | EAbs [Id] Expr
    | EXAbs Complex [Id] Expr
    | EZAbs Complex [Id] Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Complex
    = CComp Scalar Scalar
    | CComn Scalar Scalar
    | CPi
    | CE
    | CExp Complex Complex
    | CDiv Complex Complex
    | CMul Complex Complex
  deriving (C.Eq, C.Ord, C.Show, C.Read)

toplxs :: Complex -> [Id] -> Expr -> Toplevel
toplxs c x m = ToplX c x m

toplzs :: Complex -> [Id] -> Expr -> Toplevel
toplzs c x m = ToplZ c x m

edolr :: Expr -> Expr -> Expr
edolr a b = EApp a b

ecomps :: Expr -> Expr -> Expr
ecomps a b = EComp a b

eabss :: [Id] -> Expr -> Expr
eabss x m = EAbs x m

exabss :: Complex -> [Id] -> Expr -> Expr
exabss c x m = EXAbs c x m

ezabss :: Complex -> [Id] -> Expr -> Expr
ezabss c x m = EZAbs c x m

creal :: Scalar -> Complex
creal r = CComp r (Scalar "0")

cnmag :: Complex
cnmag = CComp (Scalar "0") (Scalar "-1")

cjmag :: Complex
cjmag = CComp (Scalar "0") (Scalar "1")

cpis :: Complex
cpis = CPi

